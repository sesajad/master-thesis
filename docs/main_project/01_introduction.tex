\chapter{Introduction}

Quantum computation (QC) is an emerging field that aims to use quantum mechanics to solve problems that are intractable for classical computers. Since the earliest conceptualisation of quantum computation~\cite{feynman1986}, it has been believed that quantum computers could revolutionise the way we solve problems, particularly those involving simulating nature. Over time, it has become clear that quantum computers have applications far beyond physical simulations. Algorithms for search, graph traversal, solving linear equations~\cite{montanaro2016}, machine learning and optimisation~\cite{jordan2023} have been developed.

Despite significant efforts, we are still far from fully utilising these algorithms. Our current hardware technology has not yet achieved the desired accuracy and number of qubits necessary for quantum computers to outperform classical computers in solving useful problems. The current situation is commonly referred to as the ``noisy intermediate-scale quantum'' (NISQ) era~\cite{preskill2018}, characterised by restricted resources, including a limited number of qubits, constrained qubit connectivity, hardware-specific gate sets, and limited circuit depth due to noise \cite{cross2019}.

The restricted qubit resources and excessive noise susceptibility of NISQ devices necessitate optimal compilers to have any hope of useful near-term quantum computation. A substantial amount of research has been conducted to tackle different aspects of the compilation problem, including qubit allocation \cite{itoko2019,siraichi2018,paler2019,zhang2021,li2019}, routing \cite{childs,itoko2019,cowtan2019,nash2020,kissinger2019} and gate synthesis \cite{shende2006,vatan2004,vatan2004a,shende2004,barenco1995,dawson2006}. These aspects are deeply intertwined, and one may not distinguish between them, but all of them are in some sense a circuit transformation from a higher-level circuit (with fewer imposed constraints) to a lower-level circuit (with more imposed constraints) \cite{hundt2022}.

These transformations heavily rely on SWAPs, and researchers typically try to minimise the number of SWAPs~\cite{childs,qiskit2023,sivarajah2021,itoko2019,li2019}. While a relatively overlooked fact is that, in contrast to classical compilation, SWAPs are the most expensive two-qubit gates in quantum compilation \cite{vatan2004}, there are a few works that address the inherent cost of each SWAP gate. There are a few proposed techniques to reduce the cost of SWAP gates, such as embedding SWAPs within other 2-qubit gates in the 2QAN compiler~\cite{lao2021}, or compiling a class of circuits directly into CNOT gates~\cite{kissinger2019,nash2020}. In this study, our focus is on the primary usage of SWAP gates - enabling connectivity between non-adjacent qubits. We analyse the possibility of simplification in various connectivity scenarios.

In the following, we formally define the problem of bridging as applying gates to non-adjacent qubits and review the previous efforts on that. Wen then introduce a method for implementing a class of two-qubit gates on non-adjacent qubits with $33\%$ fewer CNOTs and $66\%$ less depth compared to the baseline method. Additionally, we prove tight lower bounds for bridging each class of gates, demonstrating the optimality of our method. The introduced method could be beneficial for different approaches to impose connectivity constraints, serving as a subroutine in many widely-used routing algorithms. Furthermore, several directions for further research exist beyond our method, such as exploring the utilisation of ancillas in bridging or the simultaneous bridging of gates, all of which may lead to further useful results.

The remainder of this thesis is organised as follows. Chapter~\ref{chap:background} reviews essential background about quantum compilation and related works. In Chapter~\ref{chap:discussion}, we present our method, along with its proofs of correctness and optimality for different classes. Finally, Chapter~\ref{chap:conclusion} concludes and discusses avenues for future work.