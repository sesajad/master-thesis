\chapter{Introduction}

Quantum computation (QC) is an emerging field that aims to use quantum mechanics to solve problems that are intractable for classical computers. Since the earliest conceptualization of quantum computation~\cite{feynman1986}, it has been believed that quantum computers could revolutionize the way we solve problems, particularly those involving simulating nature. Over time, it has become clear that quantum computers have applications far beyond physical simulations. There are algorithms for search and traversing graphs, solving linear equations~\cite{montanaro2016}, and methods for machine learning and optimization~\cite{jordan2023}.

Despite significant efforts, we are still far from fully utilizing these algorithms. Our current hardware technology has not yet achieved the desired accuracy and number of qubits necessary for quantum computers to outperform classical computers in solving useful problems. The current situation is commonly referred to as the ``noisy intermediate scale quantum'' (NISQ) era~\cite{preskill2018}, characterized by restricted resources, including a limited number of qubits, constrained qubit connectivity, hardware-specific gate sets, and limited circuit depth due to noise \cite{cross2019}.

The restricted qubit resources and excessive noise susceptibility of NISQ devices necessitate optimal compilers to have any hope of useful near-term quantum computation. A huge amount of research has been conducted to tackle different aspects of the compilation problem, including qubit allocation \cite{itoko2019,siraichi2018,paler2019,zhang2021,li2019}, routing \cite{childs,itoko2019,cowtan2019,nash2020,kissinger2019} and gate synthesis \cite{shende2006,vatan2004,vatan2004a,shende2004,barenco1995,dawson2006}. These aspects are deeply intertwined and one may not distinguish between them, but all of them are in some sense a circuit transformation from a higher-level circuit (with fewer imposed constraints) to a lower-level circuit (with more imposed constraints) \cite{hundt2022}.

% TODO: improvement
These transformations heavily rely on SWAPs, and the researchers usually aim to minimize the number of SWAPs~\cite{childs,qiskit2023,sivarajah2021,itoko2019,li2019}. While a relatively neglected fact is that, in contrast to classical compilation, SWAPs are the most expensive two-qubit gates in quantum compilation \cite{vatan2004}, there are a few works addressing the inherent cost of each SWAP gate. A few proposed techniques to reduce the cost of SWAP gates, such as embedding SWAPs within other 2-qubit gates in 2QAN compiler~\cite{lao2021}, or compiling a family of circuits directly into CNOT gates~\cite{kissinger2019,nash2020}. In this work, we aim to address the primary usage of SWAP gates - enabling connectivity between non-adjacent qubits. We analyze the possibility of simplifications for different connectivity cases.

Here, we formally define the problem of bridging as applying gates on non-adjacent qubits, and review the previous efforts on that. Then we present a method to implement a family of two-qubit gates on non-adjacent qubits with $33\%$ less CNOTs and $66\%$ less depth in comparison to the baseline method. We also prove lower bounds for each family of gates, which shows that our method is optimal.
% about the importance of this work and future directions

The rest of this thesis is organized as follows. Chapter~\ref{chap:background} reviews the related works. In Chapter~\ref{chap:discussion}, we present the algorithms and prove their correctness and optimality for the classical and quantum cases. We implement the algorithms and benchmark against state-of-the-art techniques in Chapter~\ref{chap:implementation}. Finally, Chapter~\ref{chap:conclusion} concludes and discusses avenues for future work.
